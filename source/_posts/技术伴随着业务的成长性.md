---
title: 技术伴随着业务的成长性
date: 2020-11-18 23:11:00
tags:
---

我不太清楚, 起这样的名字, 会不会让人不知所云, 不过, 我觉得这是比较准确的了.
让我来解释一下.

在一个业务刚刚起步的时候, 业务的场景往往是不明确的, 你写的代码, 通常是没有太多的通用性和适配性的, 比如, 你写了很多 h5 的组件, 但是, 你现在, 还没有办法确定, 哪些是组件是可以抽象成公共组件的. 伴随着业务的发展, 一切都会比较清晰起来.

观察我手上项目的代码, 我发现很多代码, 很多组件, 都是通过复制粘贴的形式, 在各个页面中使用的. 如果你想修改其中一个组件的逻辑, 比如, 给一个图片上传组件, 增加限制图片体积的功能, 你会发现很困难, 由于组件组件是复制粘贴的形式, 所以, 你需要在很多地方都要进行修改. 这样的代码, 难以维护, 又容易出现 bug. 我有时候在实现产品提出来的,  看起来很简单的需求, 却需要花费很大的力气才能实现. 我有时候真的很难去和一个非技术背景的人解释, 为什么一个看似简单的功能, 在实现上, 却如此困难.

这种问题, 已经不是纯粹的技术问题了, 而是业务能力, 抽象能力之类的.

我在做 h5 的营销页面的时候, 也有其他的体会. 比如, 功能类似的活动聚合页, 页面上通常会有外观不一样的商品卡片组件, 商品列表组件和秒杀倒计时组件等, 但是这些页面, 却由于缺少足够的通用和抽象机制, 被活生生的拆成了不同的页面. 比如, 活动聚合页, 内容聚合页等, 这些功能, 从技术的角度来看, 就只是同一个页面, 展示了不同的组件而已. 我们重复写了这些页面, 却没有办法去解决它.

所以, 在公司的这段时间, 我也逐渐积累了很多构想.

## 举个栗子

你在写业务的时候, 比如, 我们以写一个页面为例子.
你需要分析页面的需求, 然后, 抽象出不同的组件, 但是千万要注意, 我让你抽象出组件, 不是为了**组件复用**, 而是**逻辑分治**. 也就是说, 你原本是把所有的业务逻辑, 都塞到一个页面组件中, 然后, 这个页面组件又臭又长, 逻辑又多又复杂, 代码的行数很多. 这样的组织结构, 是不方便别人理解你的代码的, 也不方便你后续修改代码. 所以, 你需要抽象出组件, 把原本塞到一起的逻辑,分散到各个组件中, 这个时候, 你的页面组件的代码量就会下降, 也更容易让别人理解你的代码逻辑是如何组织和协作的.

**补充:**

1. 为什么说, 组件抽象的目的是"分治"而不是"复用". 因为你抽象出来的组件, 最终到底能不能复用, 是取决于你的业务场景的. 也许你的写的组件, 就真的只有你的这个页面在使用而已, 别的页面就根本用不上. 而且, 业务发展的初期, 你的业务需求和业务特点都还没有明朗起来的时候, 你又该如何做到复用呢?
2. 组件抽象后, 也许你需要考虑, 兄弟组件之间, 应该如何通信呢?

所以, 你写页面的同时, 对业务逻辑进行了拆分, 抽象出来了组件来承载业务的逻辑. 这些组件, 有明确的输入和输出, 不依赖全局变量, 所以, 也很容易排查组件的 bug. 于是你继续开发页面, 这个时候, 来了一个新的页面, 你发现, 这个页面也需要某一个组件, 而且, 这个组件刚好是你之前写过了, 你只需要稍微做一下修改, 就能复用了, 所以, 你把上一个页面用到的那个组件, 保存到了一个存放公共组件的目录, 然后, 你的第二个页面, 也能愉快的直接使用这个组件了. 这样, 你的开发效率就上去了.

**补充:**

1. 有明确输入输出, 不依赖全局变量的组件, 很容易做迁移, 迁移的意思是, 我可以很放心的在别的地方使用这个组件, 因为一旦组件出现了 bug, 我只要观察组件的输入数据, 我就能排查出问题所在. 有一个实际例子, 我们管理后台写的一个图片上传组件, 由于组件内部依赖的 vuex 的一个参数, 而且是直接引用的, 不是通过参数传递进来的, 结果在某一天就意外的出现了 bug.
2. 请注意, 你在开发第一个页面的时候, 我们把这个页面叫做 page1 吧. 你抽象出来的组件, 都是存放在 page1 的目录下的, 开发第二个页面, 我们叫做 page2 吧, 这个时候, 你才会把 page2 所需要的那个组件, 从 page1 的目录迁移到存放公共组件的目录下. 通常, 在这个过程当中, 我还会给这个组件, 补充上 readme, 补充上文档和截图, 有了截图, 你就能知道这个组件长什么样子, 就能方便你快速确认这个组件是不是你需要的那一个.


遇到别人写好的公共组件, 如果需要修改才能满足你的需求的时候, 这个时候, 你要勇于去修改组件的源码来实现你的需求(这个不强求, 因为有些人的代码真的很烂, 不敢改, 做出优秀的组件, 是需要优秀的抽象思维的), 必要的时候, 可以让组件的作者帮你 review 代码. 在这个过程当中, 你一是能提到你的思维能力, 二是, 你会用到很多高级的技术, 这些技术, 可能你平时都用不上, 我们以 vuejs 来举个栗子.

比如, 你的组件的功能是, 提供一个数组, 把数组里面的数据给渲染出来(你可以理解为列表渲染). 你可能想到了, 用户需要定制一下列表项的外观, 一开始呢, 你可能通过预置几个样式, 通过提供参数来让用户选择自己想要的样式, 后面呢, 你发现, 用户对于样式的需求很特别, 你难以通过普通的方式来满足用户需求了, 这个时候, 你就会想起 vue 提供的 slots 功能了, 这样, 你就有机会用到了 slots 这个技术.

又举一个栗子, 有一个组件, 功能是出现一个弹窗, 方便你在后台关联上"优惠券". 优惠券的数据来源, 通常是通过某个接口提供的, 所以, 你可以直接把获取优惠券的逻辑, 封装在组件内部, 这个时候你可能会说, 万一我是通过别的接口来获取优惠券的, 那该怎么办呢? 所以, 这里有一个解决方案, 你让组件接受一个函数, 这个函数负责获取优惠券的数据, 并且返回一个 promise, 当你传递这个函数的时候, 组件会使用这个函数来获取数据, 如果不传, 那么默认使用组件内部封装的接口来获取数据.
给个代码栗子

```javascript
new Vue({
    props: {
        fetchData: {
            type: Function,
            default: null
        }
    },
    methods: {
        fetchCouponList() {
            // 组件自己的获取数据的方法
        }
        _fetchData() {
            let p = null;

            if (this.fetchData) {
                p = this.fetchData()
            } else {
                p = this.fetchCouponList()
            }

            return p.then((resp) => {
                // 处理接口返回的数据
            })
        }
    }
})
```


**补充**
1. 给组件传递参数, 在 vue 中似乎不常见, 不过在 react 中, 还是挺常用的.


通过这样的方式, 我们已经在项目中, 积累了大量的组件, 这个时候, 我们回过头来, 思考这个问题:

我们写的很多 h5 营销页, 活动页, 功能都是大同小异, 从技术角度来说, 可以理解为同一个页面, 分别展示了不同的组件而已, 我们如何加速这类页面的开发过程?

你当然能做到, 因为你的手上, 积累了很多组件, 然后, 你可以写一个新的页面, 给这个页面提供一份 json 文件, 这个 json 文件描述了所有用到的组件, 他们的位置和嵌套关系, 他们所需要的数据. 这样的话, 一个 h5 页面搭建平台的雏形就出来了(这个在技术上是可以行得通的, 我已经跑了一个 demo). 这个 h5 页面搭建平台的最大优势是, 可以复用我们已经写好的组件和其他的业务逻辑(比如微信登录和绑定逻辑). 这也是为什么刚到公司的时候, 我在调研开源的 h5 页面搭建平台, 但是到了最后却放弃了这些方案, 从而改成自研的原因, 因为自研的方案, 可以最大限度的匹配我们的业务场景和需求. 所以, 后来我做了一个决定, 就是尽可能的把各个不同的 h5 项目, 通过 monorepo(或则 workspace) 的方案整合到同一个项目中, 目的就是**抽象出大量的 h5 公共组件, 来提供给 h5 页面搭建平台使用**.


**补充**
1. 简单提一下, 你抽象出来的公共组件, 如果是抽象成一个单独的 npm 包的话, 虽然引用这个组件并没有麻烦, 但是需要调试和修改组件的时候, 并不方便, 这也是我为什么提到了要把相关的 h5 项目, 通过 monorepo(或则 workspace) 的方式来整合到一个项目中的原因. 这里不会详细讨论 monorepo 和 workspace 的概念.

## 总结

所以, 所谓的**成长性**是什么呢? 就是伴随的业务的发展, 你的组件, 你的代码逻辑, 你的技术方案, 越来越适配于你的业务特点, 从而能增快研发效率和系统的稳定性, 而不是你的业务, 去适配你的技术方案.
